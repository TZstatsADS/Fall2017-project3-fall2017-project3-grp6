---
title: "Project 3 - Example Main Script"
author: "Yuting Ma, Tian Zheng"
date: "February 24, 2016"
output:
  pdf_document: default
  html_document: default
---
#Install necessary packages.
```{r}
if(!require("EBImage")){
  source("https://bioconductor.org/biocLite.R")
  biocLite("EBImage")
}

packages.used=c("gbm", "caret","DMwR" ,"nnet","randomForest","e1071","data.table","readr","xgboost")
packages.needed=setdiff(packages.used, 
                        intersect(installed.packages()[,1], 
                                  packages.used))
if(length(packages.needed)>0){
  install.packages(packages.needed, dependencies = TRUE)
}

library("EBImage")
library("gbm")
library("caret")
library("DMwR")
library("nnet")
library("randomForest")
library("e1071")
library("data.table")
library("xgboost")
```
#Set the working directory to the image folder.
```{r}
setwd("/Users/sijianxuan/Documents/Github/Fall2017-project3-fall2017-project3-grp6/doc") 
# here replace it with your own path or manually set it in RStudio to where this rmd file is located.
```
#Read Data
```{r,warning=F,message=F}
sift.feature=read.csv("../data/sift_feature.csv", header = T)
lbp.feature=read.csv("../data/lbp_feature.csv", header = F)
hog.feature = read.csv("../data/hog_feature.csv")
label=read.csv("../data/trainlabel.csv")
```
#SIFT feature
#Train and Validate set 
```{r}
sift_data=data.frame(cbind(label,sift.feature[,-1]))
test.index=sample(1:3000,500,replace=F)
colnames(sift_data)[2]="y"
sift_data = sift_data[,-1]
test.sift=sift_data[test.index,]
test.x.sift=test.sift[,-1]
train.sift=sift_data[-test.index,]
```
#Baseline model: GBM + SIFT
#####Tune parameters:n.trees = 250, shrinkage = 0.1
```{r}
#y<-label[,2]
#X<-test.x.sift
#source("../lib/tune gbm.r")
# These lines of code takes a long like crazy time so I just wrote the results as a csv file.
#for(k in 1:length(depths)){
#  cat("k=", k, "\n")
#  err_cv[k,] <- cv.function(X, y, depths[k], shrinkage=shrinkages, K=5)  #K=5
#}
#colnames(err_cv) = c("mean of cv.error","sd of cv.error")
#rownames(err_cv) = c("depth = 3", "depth = 5", "depth = 7", "depth = 9","depth = 11")
#print(err_cv)
#write.csv(err_cv,file = "err_cv_for_baseline.csv")
```
#Other models + SIFT
####The 5000-dimensional SIFT feature takes a long long long time to get the results. If PCA is used to do dimension reduction, the accuracy become really low. It makes sense because doing PCA dimension reduction means losing information. So we started to use other feature extraction methods. With Zhilin's suggestion, we use Local Binary Patterns(LBP), Histogram of oriented gradients(HoG)
and Convolutional Neural Network(CNN) to extract features.
#Local Binary Patterns(LBP)
####Local Binary Pattern (LBP) is a simple yet very efficient texture operator which labels the pixels of an image by thresholding the neighborhood of each pixel and considers the result as a binary number. Due to its discriminative power and computational simplicity, LBP texture operator has become a popular approach in various applications. It can be seen as a unifying approach to the traditionally divergent statistical and structural models of texture analysis. Perhaps the most important property of the LBP operator in real-world applications is its robustness to monotonic gray-scale changes caused, for example, by illumination variations. Another important property is its computational simplicity, which makes it possible to analyze images in challenging real-time settings.
####A useful extension to the original operator is the so-called uniform pattern, which can be used to reduce the length of the feature vector and implement a simple rotation invariant descriptor. This idea is motivated by the fact that some binary patterns occur more commonly in texture images than others. A local binary pattern is called uniform if the binary pattern contains at most two 0-1 or 1-0 transitions. For example, 00010000(2 transitions) is a uniform pattern, 01010100(6 transitions) is not. In the computation of the LBP histogram, the histogram has a separate bin for every uniform pattern, and all non-uniform patterns are assigned to a single bin. Using uniform patterns, the length of the feature vector for a single cell reduces from 256 to 59. The 58 uniform binary patterns correspond to the integers 0, 1, 2, 3, 4, 6, 7, 8, 12, 14, 15, 16, 24, 28, 30, 31, 32, 48, 56, 60, 62, 63, 64, 96, 112, 120, 124, 126, 127, 128, 129, 131, 135, 143, 159, 191, 192, 193, 195, 199, 207, 223, 224, 225, 227, 231, 239, 240, 241, 243, 247, 248, 249, 251, 252, 253, 254 and 255.
####We used MATLAB to extract LBP features(adapted codes from Zhilin's work, I added a filter for color image and grayscale image). The column dimension is 59, which is much less than 5000. So it is reasonable that we expect a decreased time usage.
```{r}
source("../lib/train.r")
source("../lib/test.r")

lbpdata = data.frame(cbind(label,lbp.feature))
colnames(lbpdata)[2] = "y"
lbpdata = lbpdata[,-1]
test.lbp = lbpdata[test.index,]
test.x.lbp = test.lbp[,-1]
train.lbp = lbpdata[-test.index,]
```
#GBM + LBP
```{r}
X = train.lbp[,-1]
y = train.lbp[,1]
source("../lib/tune gbm.r")
for(k in 1:length(depths)){
  cat("k=", k, "\n")
  err_cv[k,] <- cv.function(X, y, depths[k], shrinkage=shrinkages, K=5)  #K=5
}
colnames(err_cv) = c("mean of cv.error","sd of cv.error")
rownames(err_cv) = c("depth = 3", "depth = 5", "depth = 7", "depth = 9","depth = 11")
print(err_cv)
write.csv(err_cv,file = "err_cv_for_GBM+LBP.csv")
```
#Some advanced models + LBP
###BPNN
####Tune parameters:size = 1, decay = 0.01
```{r}
bp.model=train.bp(train.lbp)
bp.pre=test.bp(bp.model,test.x.lbp)
table(bp.pre,test.lbp$y)
```
##Random Forest + LBP 
####Tune Parameter: m.try=15
```{r}
rf.model <- train.rf(train.lbp)
rf.pre=test.rf(rf.model,test.x.lbp)
table(rf.pre,test.lbp$y)
```
##SVM + LBP ####Tune Parameters: cost=10, gamma=0.01
```{r}
svm.model <- train.svm(train.lbp)
svm.pre=test.svm(svm.model,test.x.lbp)
table(svm.pre,test.lbp$y)
```
##Logistic Regression + LBP
```{r}
log.model <- train.log(train.lbp)
log.pre=test.log(log.model,test.x.lbp)
table(log.pre, test.lbp$y)
```
##xgboost
```{r}
xgboost.model = train.xgboost(train.lbp)
xgboost.pre = test.xgboost(xgboost.model,test.lbp)
table(xgboost.pre, test.lbp$y)
```
#Some advanced models + HoG
####关于hog的介绍
#Train and Validate set 
```{r}
hogdata = data.frame(cbind(label,hog.feature[,-1]))
colnames(hogdata)[2] = "y"
hogdata = hogdata[,-1]
test.hog = hogdata[test.index,]
test.x.hog = test.hog[,-1]
train.hog = hogdata[-test.index,]
```
###BPNN
####Tune parameters:size = 1, decay = 0.01
```{r}
bp.model=train.bp(train.hog)
bp.pre=test.bp(bp.model,test.x.hog)
table(bp.pre,test.hog$y)
```
##Random Forest + LBP 
####Tune Parameter: m.try=15
```{r}
rf.model <- train.rf(train.hog)
rf.pre=test.rf(rf.model,test.x.hog)
table(rf.pre,test.hog$y)
```
##SVM + LBP ####Tune Parameters: cost=10, gamma=0.01
```{r}
svm.model <- train.svm(train.hog)
svm.pre=test.svm(svm.model,test.x.hog)
table(svm.pre,test.hog$y)
```
##Logistic Regression + LBP
```{r, include=FALSE}
###tune logistic regression model
glm.fit=multinom(y~., data=training,trace = F)
#glm=multinom(y~., data=training,maxit = 500,trace = F)
summary(glm.fit)
#Prediction
glm.pred<-predict(glm.fit, testing, type = "class")
mean(testing$y==glm.pred)  ##82%

#cv
cv.lr <- function(X.train, y.train,K){
  n <- length(y.train)
  n.fold <- floor(n/K)
  s <- sample(rep(1:K, c(rep(n.fold, K-1), n-(K-1)*n.fold)))  
  cv.accu.lr <- rep(NA, K)
  
  for (i in 1:K){
    train.data <- X.train[s != i,]
    train.label <- y.train[s != i]
    test.data <- X.train[s == i,]
    test.label <- y.train[s == i]

    glm=multinom(train.label~., data=train.data,maxit = 500,trace = F)

    #Prediction
    pred<-predict(glm, test.data, type = "class")
    cv.accu.lr[i] <- mean(pred == test.label)  
    
  }			
  print(mean(cv.accu.lr))
  
}

cv.lr(training[,-1],training[,1], 5)
```
#Final LR model
```{r}
log.model <- train.log(train.hog)
log.pre=test.log(log.model,test.x.hog)
table(log.pre, test.hog$y)
```
##Xgboost
####Tune model and choose parameters
```{r, include=FALSE}
trainnn<-as.matrix(training)
testtt<-as.matrix(testing)
dtrain=xgb.DMatrix(data=trainnn[,-1],label=trainnn[,1])

#bst=xgb.train(data=dtrain,params = param,nrounds=100)

#NROUNDS = c(100,300,500,1000)
#ETA = c(0.01, 0.1, 0.2, 0.3, 0.5, 0.8)
#MAX_DEPTH = c(6, 8, 10, 15, 20)
NROUNDS = c(500,1000)
ETA = c(0.3)
MAX_DEPTH = c(3,4,5,6)

cv.xgb <- function(X.train, y.train, K, NROUNDS, ETA, MAX_DEPTH){
  for (nround in NROUNDS){
    for (eta in ETA){
      for (max_depth in MAX_DEPTH){
        n <- length(y.train)
        n.fold <- floor(n/K)
        s <- sample(rep(1:K, c(rep(n.fold, K-1), n-(K-1)*n.fold)))  
        cv.acc <- rep(NA, K)
        
        for (i in 1:K){
          train.data <- X.train[s != i,]
          train.label <- y.train[s != i]
          test.data <- X.train[s == i,]
          test.label <- y.train[s == i]
          
          param <- list("objective" = "multi:softmax",
                        "eval_metric" = "mlogloss",
                        "num_class" = 3, 'eta' = eta, 'max_depth' = max_depth)
          
          dtrain=xgb.DMatrix(data=train.data,label=train.label)
          
          bst <- xgb.train(data = dtrain,  param = param, nrounds = nround)
          pred <- predict(bst, newdata = test.data) 
          
          cv.acc[i] <- mean(pred == test.label)  
        }			
        print(paste("------Mean 5-fold cv accuracy for nround=",nround,",eta=",eta,",max_depth=",max_depth,
                    "------",mean(cv.acc)))
        key = c(nround,eta,max_depth)
        CV_ERRORS[key] = mean(cv.acc)
      
      }
    }
  }
}

CV_ERRORS = list()
cv.xgb(trainnn[,-1], trainnn[,1], 5, NROUNDS, ETA, MAX_DEPTH)
```
##Final xgboost model
```{r}
xgboost.model = train.xgboost(train.hog)
xgboost.pre = test.xgboost(xgboost.model,test.hog)
table(xgboost.pre, test.hog$y)
```
#Cross Validation Error Rate
```{r}
source("../lib/cross_validation.R")
cv.error.lbp =cv.function(lbpdata,5)
cv.error.hog = cv.function(hogdata,5)
print (cv.error.lbp)
print(cv.error.hog)
write.csv(cv.error.lbp,"cv.error.lbp.csv")
write.csv(cv.error.hog,"cv.error.hog.csv")
```
#Final Train & Time
```{r}
#a=system.time(baseline <- train.baseline(sift_data))
#b=system.time(gbm <- train.baseline(lbpdata))
c=system.time(bp <- train.bp(lbpdata))
d=system.time(rf <- train.rf(lbpdata))
e=system.time(svm <- train.svm(lbpdata))
f=system.time(logistic <- train.log(lbpdata))
g = system.time(xgboost <- train.xgboost(lbpdata))
time=list(bp=c,rf=d,svm=e,logistic=f,xgboost = g)

#$bp
#   user  system elapsed 
#  0.594   0.006   0.604 

#$rf
#   user  system elapsed 
# 84.416   0.520  85.249 

#$svm
#   user  system elapsed 
#  3.475   0.030   3.514 

#$logistic
#   user  system elapsed 
#  0.482   0.008   0.491 

#$xgboost
#   user  system elapsed 
#119.682   0.897  32.342 
```
#Final Model ####
SVM+LBP
XGBOOST+HOG
